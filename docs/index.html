<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <!-- Set doc-js class before any render so CSS initial states apply immediately -->
  <script>document.documentElement.classList.add('doc-js');</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Design System — Documentation</title>

  <!--
    CASCADE LAYER ORDER — declared before any stylesheet loads.
    ─────────────────────────────────────────────────────────────────────────
    Priority (lowest → highest):
      tokens < base < doc-shell < utilities < components < themes < adapters

    doc-shell sits AFTER base so doc layout rules are not wiped by the
    base reset (* { margin:0; padding:0 }).
    doc-shell sits BEFORE components so DS component styles always win.
    ─────────────────────────────────────────────────────────────────────────
  -->
  <style>
    @layer tokens, base, doc-shell, utilities, components, themes, adapters;
  </style>

  <!--
    CSS LOAD ORDER
    ─────────────────────────────────────────────────────────────────────────
    1. ds-preview.css   →  compiled DS output (tokens + base + components + themes)
    2. docs.css         →  documentation shell chrome — wrapped in @layer doc-shell
                           Uses --doc-* namespace; never overrides DS-layered rules.
    ─────────────────────────────────────────────────────────────────────────
  -->
  <link rel="stylesheet" href="../preview/css/ds-preview.css">
  <link rel="stylesheet" href="css/docs.css">
</head>

<body>

  <!-- ═══════════════════════════════════════════════════════════════════════════
     SHELL
     ═══════════════════════════════════════════════════════════════════════════ -->
  <div class="doc-shell">

    <!-- ── Header ──────────────────────────────────────────────────────────── -->
    <header class="doc-header" role="banner">
      <div class="doc-header__inner">
        <div class="doc-header__brand">
          <span class="doc-header__mark" aria-hidden="true">DS</span>
          <div>
            <div class="doc-header__title">Design System</div>
            <div class="doc-header__subtitle">Documentation — Phase 9</div>
          </div>
        </div>
        <nav class="doc-header__nav" aria-label="Architecture layers">
          <span class="doc-layer-badge doc-layer-badge--tokens">tokens</span>
          <span class="doc-layer-arrow" aria-hidden="true">→</span>
          <span class="doc-layer-badge doc-layer-badge--base">base</span>
          <span class="doc-layer-arrow" aria-hidden="true">→</span>
          <span class="doc-layer-badge doc-layer-badge--utils">utilities</span>
          <span class="doc-layer-arrow" aria-hidden="true">→</span>
          <span class="doc-layer-badge doc-layer-badge--components">components</span>
          <span class="doc-layer-arrow" aria-hidden="true">→</span>
          <span class="doc-layer-badge doc-layer-badge--themes">themes</span>
          <span class="doc-layer-arrow" aria-hidden="true">→</span>
          <span class="doc-layer-badge doc-layer-badge--adapters">adapters</span>
        </nav>
      </div>
    </header>

    <!-- ── Body ─────────────────────────────────────────────────────────────── -->
    <div class="doc-body">

      <!-- ── Sidebar ─────────────────────────────────────────────────────────── -->
      <aside class="doc-sidebar" aria-label="Documentation navigation">
        <div class="doc-sidebar__section">
          <div class="doc-sidebar__label">Layer</div>
          <div class="doc-sidebar__layer-pill">components</div>
        </div>
        <div class="doc-sidebar__section">
          <div class="doc-sidebar__label">Component</div>
          <!--
          REGISTRY-DRIVEN: component nav links are injected by
          RegistryEngine.buildDocNav(). No manual edits required.
        -->
          <nav id="doc-component-nav">
            <span style="font-size:0.75rem;color:var(--semantic-color-text-disabled);">Loading…</span>
          </nav>
        </div>
        <div class="doc-sidebar__section">
          <div class="doc-sidebar__label">On this page</div>
          <!--
          REGISTRY-DRIVEN: TOC links are injected by RegistryEngine.buildDocTOC().
        -->
          <nav class="doc-toc" id="doc-toc-nav">
            <!-- injected after page build -->
          </nav>
        </div>
      </aside>

      <!-- ── Main ──────────────────────────────────────────────────────────── -->
      <!--
      REGISTRY-DRIVEN DOCS ENGINE
      All documentation content is generated by RegistryEngine.buildDocPage().
      The id and content of this element are set at runtime based on which
      component is selected. No hardcoded component markup exists in this file.
      To add documentation for a new component:
        1. Create component SCSS files
        2. Add full registry entry to preview/data/component.registry.json
      No HTML edits required.
    -->
      <main class="doc-main" id="doc-main" role="main">
        <!-- Loading scaffold — replaced by RegistryEngine.buildDocPage() -->
        <div id="doc-loading-scaffold"
          style="display:flex;align-items:center;justify-content:center;height:100%;flex-direction:column;gap:1rem;color:var(--semantic-color-text-subtle);">
          <div style="font-size:2rem;" aria-hidden="true">⟳</div>
          <p style="font-size:0.875rem;">Loading documentation…</p>
        </div>
      </main>
      <!-- /Main -->

    </div>
    <!-- /Body -->

  </div>
  <!-- /Shell -->

  <!--
  NOTE ON FORCED STATE CLASSES
  doc-force-hover / doc-force-focus / doc-force-active are documentation-only
  classes that simulate visual states. CSS below in docs.css adds matching
  styles. These classes are never part of the DS component API.
-->


  <!-- SCRIPTS — Registry engine must load before the async init block -->
  <script src="../preview/js/token-registry.js"></script>
  <script src="../preview/js/registry-engine.js"></script>

  <!-- ═══════════════════════════════════════════════════════════════════════════
     MOTION.JS — Animations + Smooth Scroll
     https://motion.dev  (Motion v11 — ES module via CDN)
     ═══════════════════════════════════════════════════════════════════════════
     Architecture note:
       All animations are additive and respect prefers-reduced-motion.
       Initial opacity:0 states are set with .doc-js CSS class so elements
       are never visible before JS runs — no flash.
       Motion runs entirely outside the DS @layer stack.
     ═══════════════════════════════════════════════════════════════════════════ -->
  <script type="module">
    import { animate, stagger, inView }
      from 'https://cdn.jsdelivr.net/npm/motion@latest/+esm';

    /*
      spring() cannot be used as a CSS `easing` value alongside array keyframes
      in Motion v11 — spring has its own duration model that conflicts.
      Use a bouncy cubic-bezier instead.
    */
    const BOUNCE = 'cubic-bezier(0.34, 1.56, 0.64, 1)';
    const EASE_OUT = 'ease-out';

    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    /* ─────────────────────────────────────────────────────────────────────────────
       PAGE ENTRANCE — runs once on initial load (static shell elements only)
    ───────────────────────────────────────────────────────────────────────────── */
    function runPageEntrance() {
      if (reduced) {
        document.documentElement.classList.remove('doc-js');
        return;
      }

      animate('.doc-header',
        { opacity: [0, 1], y: [-8, 0] },
        { duration: 0.4, easing: EASE_OUT }
      );

      animate('.doc-layer-badge',
        { opacity: [0, 1], y: [6, 0], scale: [0.88, 1] },
        { duration: 0.45, delay: stagger(0.06, { start: 0.18 }), easing: BOUNCE }
      );

      animate('.doc-sidebar',
        { opacity: [0, 1], x: [-16, 0] },
        { duration: 0.45, delay: 0.12, easing: EASE_OUT }
      );
    }

    /* ─────────────────────────────────────────────────────────────────────────────
       DOC CONTENT ANIMATIONS — re-runs on every ds:doc-ready (component switch)
    ───────────────────────────────────────────────────────────────────────────── */
    function runDocAnimations() {
      if (reduced) return;

      const overview = document.getElementById('section-overview');
      if (overview) {
        animate(overview, { opacity: [0, 1], y: [18, 0] }, { duration: 0.5, delay: 0.05, easing: EASE_OUT });
      }

      animate('.doc-toc__link',
        { opacity: [0, 1], x: [-8, 0] },
        { duration: 0.3, delay: stagger(0.05, { start: 0.1 }), easing: EASE_OUT }
      );

      document.querySelectorAll('.doc-section:not(#section-overview)').forEach(el => {
        inView(el,
          () => { animate(el, { opacity: [0, 1], y: [22, 0] }, { duration: 0.48, easing: EASE_OUT }); },
          { amount: 0.06 }
        );
      });

      document.querySelectorAll('.doc-demo-grid').forEach(grid => {
        const rows = grid.querySelectorAll('.doc-demo-row');
        if (!rows.length) return;
        inView(grid,
          () => { animate(rows, { opacity: [0, 1], y: [10, 0] }, { duration: 0.32, delay: stagger(0.07), easing: EASE_OUT }); },
          { amount: 0.04 }
        );
      });

      document.querySelectorAll('.doc-token-table').forEach(table => {
        const rows = table.querySelectorAll('tbody tr');
        if (!rows.length) return;
        inView(table,
          () => { animate(rows, { opacity: [0, 1], x: [-8, 0] }, { duration: 0.28, delay: stagger(0.05), easing: EASE_OUT }); },
          { amount: 0.08 }
        );
      });

      const ruleList = document.querySelector('.doc-rule-list');
      if (ruleList) {
        inView(ruleList,
          () => { animate(ruleList.querySelectorAll('.doc-rule'), { opacity: [0, 1], x: [-10, 0] }, { duration: 0.32, delay: stagger(0.08), easing: EASE_OUT }); },
          { amount: 0.04 }
        );
      }

      document.querySelectorAll('.doc-callout').forEach(el => {
        inView(el,
          () => { animate(el, { opacity: [0, 1], y: [8, 0] }, { duration: 0.38, easing: EASE_OUT }); },
          { amount: 0.1 }
        );
      });

      const matrix = document.querySelector('.doc-state-matrix');
      if (matrix) {
        inView(matrix,
          () => { animate(matrix.querySelectorAll('.doc-state-matrix__row'), { opacity: [0, 1], y: [8, 0] }, { duration: 0.3, delay: stagger(0.1), easing: EASE_OUT }); },
          { amount: 0.1 }
        );
      }

      const metaTable = document.querySelector('.doc-meta-table');
      if (metaTable) {
        inView(metaTable,
          () => { animate(metaTable.querySelectorAll('tr'), { opacity: [0, 1], x: [-6, 0] }, { duration: 0.26, delay: stagger(0.05), easing: EASE_OUT }); },
          { amount: 0.1 }
        );
      }

      /* ── Smooth scroll — wired to dynamically-injected anchors ── */
      document.getElementById('doc-main')?.querySelectorAll('a[href^="#"]').forEach(link => {
        link.addEventListener('click', e => {
          const id = link.getAttribute('href').slice(1);
          const target = document.getElementById(id);
          if (!target) return;
          e.preventDefault();
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
      });

      /* ── Active TOC link — re-observed on each component switch ── */
      const sections = document.querySelectorAll('.doc-section[id]');
      const tocLinks = document.querySelectorAll('.doc-toc__link');
      if (sections.length && tocLinks.length) {
        const tocObserver = new IntersectionObserver(entries => {
          entries.forEach(entry => {
            if (!entry.isIntersecting) return;
            const id = entry.target.id;
            tocLinks.forEach(l => {
              const isActive = l.getAttribute('href') === `#${id}`;
              l.classList.toggle('doc-toc__link--active', isActive);
              if (isActive && !reduced) {
                animate(l, { x: [0, 4, 0] }, { duration: 0.28, easing: 'ease-out' });
              }
            });
          });
        }, { rootMargin: '-15% 0px -72% 0px', threshold: 0 });
        sections.forEach(s => tocObserver.observe(s));
      }
    }

    // Fire page entrance immediately (static shell is already in the DOM)
    runPageEntrance();

    // Fire doc content animations each time a component doc is rendered
    document.addEventListener('ds:doc-ready', runDocAnimations);
  </script>

  <!-- ═══════════════════════════════════════════════════════════════════════════
     PHASE 9 — ASYNC REGISTRY INIT
     Loads component.registry.json + adapter.registry.json, then builds the
     full documentation page driven entirely from JSON metadata.
     No hardcoded component markup anywhere in this file.
     ═══════════════════════════════════════════════════════════════════════════ -->
  <script>
    (async function () {
      'use strict';

      await RegistryEngine.init();

      // Remove loading scaffold
      const scaffold = document.getElementById('doc-loading-scaffold');
      if (scaffold) scaffold.remove();

      /**
       * Load and render a component's documentation page.
       * Called on initial load and whenever the user switches components.
       */
      function loadDocComponent(id) {
        RegistryEngine.buildDocNav(
          document.getElementById('doc-component-nav'), id
        );
        RegistryEngine.buildDocPage(
          id, document.getElementById('doc-main')
        );
        RegistryEngine.buildDocTOC(
          id, document.getElementById('doc-toc-nav')
        );
        // Signal Motion.js and any other listeners that new content is ready
        document.dispatchEvent(
          new CustomEvent('ds:doc-ready', { detail: { componentId: id } })
        );
      }

      // Load the first registered component on page open
      const firstId = Object.keys(window.DS_REGISTRY?.components || {})[0] || 'button';
      loadDocComponent(firstId);

      // Delegated click handler for the component nav sidebar
      document.getElementById('doc-component-nav')?.addEventListener('click', e => {
        const link = e.target.closest('[data-doc-nav]');
        if (link) loadDocComponent(link.dataset.docNav);
      });

    })();
  </script>

</body>

</html>